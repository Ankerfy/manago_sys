原有的 `useProgress.js` 代码已经写得非常清晰、健壮，**核心逻辑完全正确**。不过，结合你之前提到的架构目标（**Pinia 统一管理状态 + composables 作为组件层适配器**），以及避免“双入口”问题，**建议做如下调整**：

---

### ✅ 目标：让 `useProgress` 成为 **Pinia Store 的轻量级代理**

> 🎯 **原则**：
>
> - 真实状态 (`isLoading`) 和业务逻辑应由 **Pinia Store** 持有；
> - `useProgress()` 只负责在组件中**便捷地访问 Store**，不维护自己的状态。

否则会出现：

- 组件调用 `useProgress().start()` → 更新本地 `isLoading`
- 路由调用 `useProgressStore().start()` → 更新 Store 的 `isLoading`
- 两者**状态不同步**！

---

### 🔧 推荐修改方案

#### 步骤 1：先确保你已创建 Pinia Store（假设为 `progressStore.js`）

#### 步骤 2：修改 `useProgress.js` —— **只代理 Store**

```js
// @/composables/useProgress.js
import { useProgressStore } from '@/stores/progressStore'

/**
 * Vue 3 组合式函数：用于在组件中便捷访问全局进度条状态
 * 实际状态和逻辑由 Pinia Store 管理
 */
export function useProgress() {
  const store = useProgressStore()

  return {
    isLoading: store.isLoading,
    start: store.start,
    finish: store.finish,
  }
}
```

✅ **改动说明**：

- 删除了 `ref(isLoading)` —— 不再维护本地状态；
- 所有操作委托给 `useProgressStore()`；
- 组件中使用方式**完全不变**，但状态现在是全局统一的。

---

### ✅ 使用效果对比

| 场景       | 修改前                                       | 修改后                          |
| ---------- | -------------------------------------------- | ------------------------------- |
| 组件中调用 | `const { isLoading, start } = useProgress()` | ✅ 用法不变                     |
| 路由中调用 | ❌ 无法使用 `useProgress`，需绕道 `utils`    | ✅ `useProgressStore().start()` |
| 状态同步   | ❌ 组件与路由状态分离                        | ✅ 全局唯一状态源               |
| 测试/调试  | 难以追踪状态来源                             | Pinia Devtools 可视化           |

### ✅ 总结

| 文件                           | 操作                                      |
| ------------------------------ | ----------------------------------------- |
| `@/composables/useProgress.js` | **重构成 Pinia Store 的代理**（如上所示） |
| `@/stores/progressStore.js`    | **新建**（内容见上）                      |
| `@/router/index.js`            | 改为 `useProgressStore().start(...)`      |
| `@/utils/stagedProgress.js`    | 保持不变（仅执行动画）                    |

---

原有路由配置直接调用 `utils/stagedProgress.js` 中的 `start` / `end`，这会导致**进度状态（如 `isLoading`）无法与组件同步**。为实现 **全局状态统一管理**，应改为使用 **Pinia Store**。

---

### ✅ 改动目标

- ✅ 路由中通过 `useProgressStore().start()` 触发进度条
- ✅ 自动同步 `isLoading` 状态到所有组件
- ✅ 保持原有动画逻辑不变（仍由 `stagedProgress.js` 执行）

---

### 🔧 修改步骤

#### 第 1 步：确保已创建 `progressStore.js`

如果你还没创建，请先添加：

```js
// @/stores/progressStore.js
import { defineStore } from 'pinia'
import { startProgress, endProgress } from '@/utils/stagedProgress'

// 提取默认阶段配置（避免重复）
export const DEFAULT_PROGRESS_STAGES = [
  { value: 0.1, delay: 200 },
  { value: 0.1, delay: 500 },
  { value: 0.4, delay: 300 },
  { value: 0.4, delay: 400 },
  { value: 0.8, delay: 200 },
  { value: 1.0, delay: 100 },
]

export const useProgressStore = defineStore('progress', {
  state: () => ({
    isLoading: false,
  }),
  actions: {
    async start(stages = DEFAULT_PROGRESS_STAGES) {
      this.isLoading = true
      try {
        await startProgress(stages)
      } finally {
        this.isLoading = false
      }
    },
    finish() {
      endProgress()
      this.isLoading = false
    },
  },
})
```

---

#### 第 2 步：修改路由文件（重点！）

```js
// @/router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import { useUIStore } from '@/stores' // 👈 新增导入

const router = createRouter({...})

// ⚠️ 注意：Pinia 实例必须已安装，才能在非组件中使用 useXXXStore()
// 确保在 main.js 中 app.use(pinia) 在 app.use(router) 之前！

router.beforeEach(async (to, from, next) => {
  const progress = useProgressStore()

  try {
    // 取消上一次（如果还在进行）
    progress.finish()
    // 启动新进度
    await progress.start()
    next()
  } catch (error) {
    console.warn('Route progress error:', error)
    next()
  }
})

router.onError(() => {
  const progress = useProgressStore()
  progress.finish()
})

export default router
```

---

### ⚠️ 关键注意事项

#### ❗ 1. **Pinia 必须在 Router 之前安装**

否则在 `router.beforeEach` 中调用 `useProgressStore()` 会报错：“getActivePinia was called with no active Pinia”。

---

#### ❗ 2. **移除对 `stagedProgress.js` 的直接引用**

全部交由 Store 处理。

---

### ❗ 3. **错误处理建议增强**

你当前的 `catch` 直接 `next()`，但最好也结束进度条：

```js
} catch (error) {
  const progress = useProgressStore()
  progress.finish() // 确保清理
  next()
}
```

不过由于 `progress.start()` 内部有 `finally { isLoading = false }`，其实已经安全。可选。

---

### ✅ 最终效果

| 场景               | 行为                                                         |
| ------------------ | ------------------------------------------------------------ |
| 用户切换路由       | 路由 → 调用 Store.start() → 更新 `isLoading=true` + 触发动画 |
| 组件中显示加载状态 | `const { isLoading } = useProgress()` → 响应式同步           |
| 路由跳转完成       | 动画结束 → `isLoading=false`                                 |
| 异常中断           | `finish()` 强制结束，状态归零                                |

✅ **状态唯一、逻辑集中、动画复用、组件响应**。

### 🎁 额外建议：提取 `DEFAULT_PROGRESS_STAGES`

你已经在 Store 中定义了 `DEFAULT_PROGRESS_STAGES`，路由中无需重复写。如果未来要动态调整（比如根据网络状况），只需改 Store 即可。

完成以上改动后，你的架构就达到了：

> **Utils（动画执行） ← Store（状态+协调） ← Composables/Router（消费）**

清晰、可维护、可测试！
